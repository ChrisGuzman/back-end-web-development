<!DOCTYPE html>
<html>
  <head>
    <title>Object-Oriented Programming with Ruby</title>
    <meta charset="utf-8" />

    <script src="js/remark-0.4.4.min.js"></script>
    <script src="js/jquery.min.js"></script>

    <script>
      remark.config({
        highlightStyle: "solarized_dark"
      });

      var hljs = remark.highlighter.engine();

      // extract the embedded styling from ansi spans
      remark.on('ready', function() {
        $('code.terminal > span.ansi').replaceWith(function(i, x) {
          return(x.replace(/&lt;(\/?(\w+).*?)&gt;/g, '<$1>'))
        });
      });
    </script>
    <script src="js/terminal.language.js"></script>
    <link rel="stylesheet" type="text/css" href="css/droid_serif.css" />
    <link rel="stylesheet" type="text/css" href="css/yanone_kaffeesatz.css" />
    <style type="text/css">
      body {
        font-family: 'Droid Serif';
        font-size: medium;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .small * {
        font-size: small !important;
      }
      code {
        border-radius: 5px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .footnote {
        position: absolute;
        font-size: small;
        bottom: 3em;
        right: 3em;
      }
    </style>
  </head>
  <body><textarea id="source" readonly>

class: center

# Object-Oriented Programming with Ruby

![Ruby](img/ruby-logo.png)

[http://pjb3.me/bewd-ruby-oo](http://pjb3.me/bewd-ruby-oo)

.footnote[
  created with [remark](http://github.com/gnab/remark)
]

---

# Seting up our project

Initialize a git repo

    .terminal
    ~/bewd $ git init
    Initialized empty Git repository in /Users/pbarry/bewd/.git/

Add a file

    .terminal
    ~/bewd $ echo 'puts "Hello World"' > my_program.rb
    ~/bewd $ cat my_program.rb
    puts "Hello World"
    ~/bewd $ ruby my_program.rb
    Hello World
    ~/bewd $ git add my_program.rb

Commit it

    .terminal
    ~/bewd $ git commit -m 'Hello, World!'
    [master (root-commit) 7e830fe] Hello, World!
     1 file changed, 1 insertion(+)
     create mode 100644 my_program.rb
    ~/bewd $ git --no-pager log
    commit 7e830fed3ff0ea51793d42d1e0c7367d28ad57a8
    Author: Paul Barry <mail@paulbarry.com>
    Date:   Mon Sep 9 05:38:09 2013 +0200

        Hello, World!

---

# Defining A Class

All Objects have a Class. You can use the built in ones or create your own.

```ruby
class Product
end
```

An Object is an instance of a Class.

You create an object by instantiating the class.

You instantiate a class by calling `new` method on the class

```ruby
product = Product.new

puts product.inspect
```

    .terminal
    $ ruby my_program.rb
    #<Product:0x007fd9b29f5c48>

Commit it

    .terminal
    $ git commit -am 'defined a class'
    [master ea24f40] defined a class
     1 file changed, 3 insertions(+), 7 deletions(-)

---

# Initializers and Instance Variables

```ruby
class Product
  def initialize(name, price)
    @name = name
    @price = price
  end
end

product = Product.new("iPhone", 499)

puts product.inspect
```

The `initialize` method is called the initializer (or constructor, in other languages).  It is run when the object is created with `new`

Instance variables start with a `@` and can be accessed from within the class

    .terminal
    $ ruby my_program.rb
    #<Product:0x007fe0eb1f57d8 @name="iPhone", @price=499>

Commit it

    .terminal
    $ git commit -am 'added an initializer to initialize instance variables'
    [master b30991e] added an initializer to initialize instance variables
     1 file changed, 5 insertions(+), 1 deletion(-)

---

# Reader methods

```ruby
class Product
  def initialize(name, price)
    @name = name
    @price = price
  end

  def name
    @name
  end

  def price
    @price
  end
end

product = Product.new("iPhone", 499)

puts product.name
puts product.price
```

Accessor methods expose the Objects instance variables refer to outside of the class

    .terminal
    $ ruby my_program.rb
    iPhone
    499

---

# Writer methods

```ruby
class Product
  # Constructor omitted...
  def name
    @name
  end

  def name=(name)
    @name = name
  end

  def price
    @price
  end

  def price=(price)
    @price = price
  end
end

product = Product.new
product.name = "iPhone"
product.price = 499

puts product.inspect
puts product.name
puts product.price
```

---

# attr_accessor

Have Ruby generate readers and writers for you with `attr_accessor`

```ruby
class Product
  attr_accessor :name, :price

  def initialize(name=nil, price=nil)
    @name = name
    @price = price
  end
end

product = Product.new
product.name = "iPhone"
product.price = 499

puts product.inspect

puts product.name
puts product.price
```

---

# State

Objects hold state

```ruby
class Catalog
  def products
    @products ||= []
  end

  def add(product)
    products << product
  end
end
```

`||=` is the short for

```ruby
if @products
  @products
else
  @products = []
end
```

Add products to the catalog

```ruby
catalog = Catalog.new
catalog.add Product.new("iPhone", 499)
catalog.add Product.new("T-Shirt", 19)
```

---

# Inheritance

You can subclass a class to override or extend behavior

```ruby
class CatalogDatabase < Catalog
  def add(product)
    super
    add_to_database(product)
  end

  def add_to_database(product)
    puts "Adding #{product.inspect} to the database"
    # TODO: Add code to add to database
  end
end
```

    .terminal
    $ irb -r ./my_program
    >> catalog = CatalogDatabase.new
    => #<CatalogDatabase:0x007f98acabd370>
    >> catalog.add Product.new("iPhone", 499)
    Adding #<Product:0x007f98acaa6328 @name="iPhone", @price=499> to the database
    >> catalog.add Product.new("T-Shirt", 19)
    Adding #<Product:0x007f98aca8d530 @name="T-Shirt", @price=19> to the database
    >> catalog
    => #<CatalogDatabase:0x007f98acabd370 @products=[#<Product:0x007f98acaa6328 ...
    >> catalog.class.ancestors
    => [CatalogDatabase, Catalog, Object, Kernel, BasicObject]

---

# Modules

Modules are used to share behavior

```ruby
module DatabasePersistence
  def add_to_database
    puts "Adding #{inspect} to the database"
  end
end

class Product
  include DatabasePersistence
end

class CatalogDatabase < Catalog
  def add(product)
    super
    product.add_to_database
  end
end
```

    .terminal
    $ irb -r ./my_program
    >> catalog = CatalogDatabase.new
    => #<CatalogDatabase:0x007fcf59b51758>
    >> catalog.add Product.new("T-Shirt", 19)
    Adding #<Product:0x007fcf59b3a490 @name="T-Shirt", @price=19> to the database
    >> Product.ancestors
    => [Product, DatabasePersistence, Object, Kernel, BasicObject]

---

# Blocks

Used for iteration, but also much more

```ruby
catalog.products.each do |product|
  puts "#{product.name} #{product.price}"
end
```

Same as

```ruby
for product in catalog.products
  puts "#{product.name} #{product.price}"
end
```

To get an Array of all prices, you could do this

```
prices = []
for product in products
  prices << product.price
end
prices
```

This is shorter and much more common

    .terminal
    >> catalog.products.map{|p| p.price }
    => [499, 19]

---

# Enumerable

Return only elements that the block evaluates to truthy for

    .terminal
    >> [1,2,3,4,5].select{|e| e.even? }
    => [2, 4]

Return the first element that the block evaluates to truthy for

    .terminal
    >> [1,2,3,4,5].detect{|e| e.even? }
    => 2

Sort the elements based on what is returned by the block

    .terminal
    >> people = [{ name: 'Peter' }, { name: 'Paul' }, { name: 'Mary' }]
    => [{:name=>"Peter"}, {:name=>"Paul"}, {:name=>"Mary"}]
    >> people.sort_by{|p| p[:name] }
    => [{:name=>"Mary"}, {:name=>"Paul"}, {:name=>"Peter"}]

See more at [http://ruby-doc.org/core-2.0.0/Enumerable.html](http://ruby-doc.org/core-2.0.0/Enumerable.html)

---

# self

```ruby
class Product
  DISCOUNT_RATE = 0.2

  attr_accessor :name, :price

  def discount
    price * DISCOUNT_RATE
  end
end
```

In this example, because there is no local variable price, it calls the `price` method of the instance

---

# Gotchas

Local variables take precedence of methods. This doesn't work:

```ruby
class Product
  def reduce_price(amount)
    price = price - amount
  end
end
```

Because it creates a local variable price that is then unused. This is how to do that:

```ruby
class Product
  def reduce_price(amount)
    self.price = price - amount
  end
end
```

---

# Shadowing methods with local variables

Be careful of shadowing a method with a local variable

```ruby
class Product
  def discount
    price = 99
    price * DISCOUNT_RATE
  end
end
```

You can always call the method instead of the local variable if you use self

```ruby
class Product
  def discount
    price = 99
    self.price * DISCOUNT_RATE
  end
end
```


---

# Flexible Initializer

It would be nice to be able to create products like this

    .terminal
    $ irb -r ./my_program
    >> Product.new(name: 'iPhone', price: 499)
    => #<Product:0x007f89652b4878 @name="iPhone", @price=499>

In this version, the Product initializer takes a single argument, a Hash, of the attributes and their values

Using this, we could add more attributes and not have to modify all code using Product

Also, if there are a lot of attributes, we can omit some, put them in any order and it is still clear what they are

How do we do this?

---

# Dynamically calling a writer

A writer is just syntactic sugar for calling a method than ends in `=`

    .terminal
    >> product.name = 'iPhone'
    => "iPhone"
    >> product.name=('iPhone')
    => "iPhone"

If it's just a method, then we can call it with send

    .terminal
    >> product.send('name=', 'iPhone')
    => "iPhone"

If we can call it with send, we can dynamically create the name of the writer

    .terminal
    >> attr = 'name'
    => "name"
    >> product.send("#{attr}=", 'iPhone')
    => "iPhone"

---

# Putting it together

The `each` method yields each key and value to it's block

```Ruby
class Product
  attr_accessor :name, :price

  def initialize(attrs={})
    attrs.each do |attr, value|
      send("#{attr}=", value)
    end
  end
end
```

    .terminal
    $ irb -r ./my_program
    >> Product.new(name: 'iPhone', price: 499)
    => #<Product:0x007f89652b4878 @name="iPhone", @price=499>

---

# Class Methods

If you prefix the method name with `self.`, it makes it a method of the Class, instead of an instance methods

```ruby
class Product
  def self.find(name)
    # TODO: Make this work
    puts "I'm supposed to find the product named '#{name}'"
  end
end
```

    .terminal
    $ irb -r ./my_program
    >> Product.find('iPhone')
    I'm supposed to find the product named 'iPhone'
    => nil
    >> Product.new.find
    NoMethodError: undefined method `find' for #<Product:0x007f8223ae59a0>
      from (irb):7
      from /Users/pbarry/.rbenv/versions/2.0.0-p247/bin/irb:12:in `<main>'

---

# Classes can have instance variables

Because Classes are Objects, instances of the Class Class, they have instance variables

```ruby
class Product
  attr_accessor :name, :price
end
```

is equivalent to

```ruby
Product = Class.new do
  attr_accessor :name, :price
end
```

A Class is just an instance of Class that is assigned to a Constant

---

# Pulling It Together

```ruby
class Product
  attr_accessor :name, :price

  def initialize(attrs={})
    attrs.each do |attr, value|
      send("#{attr}=", value)
    end
  end

  def self.products
    @products ||= []
  end

  def self.add(attrs)
    products << new(attrs)
  end

  def self.find(name)
    products.detect{|p| p.name == name }
  end
end
```

---

# Pulling It Together

    .terminal
    $ irb -r ./my_program
    >> Product.add(name: 'T-Shirt')
    => [#<Product:0x007f8223b46e30 @name="T-Shirt">]
    >> Product.add(name: 'iPhone', price: 499)
    => [#<Product:0x007f8223b46e30 @name="T-Shirt">, ...]
    >> Product.find('iPhone')
    => #<Product:0x007f8223b25870 @name="iPhone", @price=499>

---

# Automated tests

```ruby
require 'minitest/autorun'

class HelloTest < MiniTest::Unit::TestCase
  def test_hello
    assert_equal "hello", "hello"
  end
end
```

    .terminal
    $ ruby my_test.rb
    Run options: --seed 10484

    # Running:

    .

    Finished in 0.001633s, 612.3699 runs/s, 612.3699 assertions/s.

    1 runs, 1 assertions, 0 failures, 0 errors, 0 skips

---

# Homework

Make an object-oriented version of the program we created in the last class. Once your program is working, this test should pass.

```ruby
require 'minitest/autorun'

# Write your code here

class OrderTest < MiniTest::Unit::TestCase
  def test_total_price
    Product.add(name: "Muffin", price: 2.99)
    Product.add(name: "Coffee", price: 3.75)
    Product.add(name: "Smoothie", price: 3.99)

    order = Order.new(tax_rate: 0.05)

    order.add 2, "Muffin"
    order.add 1, "Coffee"
    order.add 1, "Smoothie"

    assert_equal 14.41, order.total_price
  end
end
```
  </textarea><div id="slideshow"></div>
  </body>
</html>
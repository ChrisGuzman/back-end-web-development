<!DOCTYPE html>
<html>
  <head>
    <title>Git</title>
    <meta charset="utf-8" />

    <script src="js/remark-0.4.4.min.js"></script>
    <script src="js/jquery.min.js"></script>

    <script>
      remark.config({
        highlightStyle: "solarized_dark"
      });

      var hljs = remark.highlighter.engine();

      // extract the embedded styling from ansi spans
      remark.on('ready', function() {
        $('code.terminal > span.ansi').replaceWith(function(i, x) {
          return(x.replace(/&lt;(\/?(\w+).*?)&gt;/g, '<$1>'))
        });
      });
    </script>
    <script src="js/terminal.language.js"></script>
    <link rel="stylesheet" type="text/css" href="css/droid_serif.css" />
    <link rel="stylesheet" type="text/css" href="css/yanone_kaffeesatz.css" />
    <style type="text/css">
      body {
        font-family: 'Droid Serif';
        font-size: medium;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .small * {
        font-size: small !important;
      }
      code {
        border-radius: 5px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .footnote {
        position: absolute;
        font-size: small;
        bottom: 3em;
        right: 3em;
      }
    </style>
  </head>
  <body><textarea id="source" readonly>

class: center

# Intro to Ruby

![Ruby](img/ruby-logo.png)

.footnote[
  created with [remark](http://github.com/gnab/remark)
]

---

# Your First Ruby Program

    .terminal
    $ echo 'puts "Hello World"' > hello.rb
    $ cat hello.rb
    puts "Hello World"
    $ ruby hello.rb
    Hello World

---

# Interactive Ruby

    .terminal
    $ irb
    >> puts "Hello World"
    Hello World
    => nil

---

# Objects

All values in Ruby are Objects.  The type of an object is determined by it's class.

## Strings

    .terminal
    >> "Hello World"
    => "Hello World"
    >> "Hello World".class
    => String    

## Integers

    .terminal
    >> 42
    => 42
    >> 42.class
    => Fixnum

## Floating Point Numbers

    .terminal
    >> 3.14159
    => 3.14159
    >> 3.14159.class
    => Float

There are lots more we will learn...
---

# Expressions

Expressions evaluate to an Object

## Mathematical Operators

    .terminal
    >> 41 + 1
    => 42
    >> 43 - 1
    => 42
    >> 6 * 7
    => 42
    >> 210 / 5
    => 42
    >> 42 % 10
    => 2
---

# Expressions

## Boolean Operators

Equality

    .terminal
    >> 42 == 42
    => true
    >> 42 == 21 * 2
    => true
    >> 42 != 10
    => true
    
Different types of objects are not equal    
    
    .terminal
    >> 42 == "42"
    => false
    
Comparison

    >> 5 > 2
    => true
    >> 6 <= 5
    => false

---

# Expressions

## String Operators

The `+` operator concatenates strings together into a new string

    .terminal
    >> "Hello" + " " + "World"
    => "Hello World"
    
The `<<` operator appends to a string
    
    .terminal
    >> "Hello" << " World"
    => "Hello World"

Interpolation allows you to include the result of evaluating an expression in a String    
    
    .terminal
    >> "40 + 2 = #{40 + 2}"
    => "40 + 2 = 42"

If you don't want interpolation to occur, use single quotes or precede   the `#` with `\`

    .terminal
    >> '40 + 2 = #{40 + 2}'
    => "40 + 2 = \#{40 + 2}"

---

# Variables

Variables are named referenced to objects

    .terminal
    >> my_name = "Paul"
    => "Paul"
    >> my_name
    => "Paul"
    >> my_name == "Paul"
    => true
    >> my_name == 42
    => false

---

# Arrays

Arrays are Objects that are an ordered collection of Objects

    .terminal
    >> [42,99,100]
    => [42,99,100]
    >> some_numbers = [42,99,100]
    => [42,99,100]
    >> some_numbers == [42,99,100]
    => true

Arrays are indexed starting with 0.  Think of the index as the offset from the first element.

    .terminal
    >> some_numbers[0]
    => 42
    >> some_numbers[2]
    => 100

You can add elements to an Array

    .terminal
    >> some_numbers << 2001
    => [42, 99, 100, 2001]
    >> some_numbers[3]
    => 2001

---

# Objects can change

You can assign new objects to a variable

    .terminal
    >> my_name = "John"
    => "John"

Some operators modify the object

    .terminal
    >> my_name << " Doe"
    => "John Doe"
    >> my_name
    => "John Doe"    

Some operators return a new object

    .terminal
    >> my_name = "John"
    => "John"
    >> my_name + " Doe"
    => "John Doe"
    >> my_name
    => "John"

---

# Multiple variables can refer to the same object

If the object changes, since these variables are referring to the same object, you see the change in both variables

    .terminal
    >> my_name = "John"
    => "John"
    >> name = my_name
    => "John"
    >> my_name << " Doe"
    => "John Doe"
    >> name
    => "John Doe"

![Diagram](img/reference_diagram.png)

---

# Constants

Constants begin with a capital letter and are variables that you don't intend to change

    .terminal
    >> NAME = "Paul"
    => "Paul"

You will get a warning if you change a constant

    .terminal
    >> NAME = "John"
    (irb):5: warning: already initialized constant NAME
    (irb):4: warning: previous definition of NAME was here

You Object the constant refers to change change

    .terminal
    => "John"
    >> NAME << " Doe"
    => "John Doe"
    >> NAME
    => "John Doe"

Although that is not typical

---

# Symbols

Used for labeling things in code

    .terminal
    >> :paul
    => :paul
    >> :paul.class
    => Symbol
    
Symbols are similar to Strings    

    .terminal
    >> my_name = :paul
    => :paul
    >> "Hello #{my_name}"
    => "Hello paul"
    
but Symbols are not the same type as Strings, so they are not equal to Strings
    
    .terminal
    >> :paul == "paul"
    => false
    
---

# Hashes

A collection of objects named with keys

    .terminal
    >> { :name => "Paul", :age => 35 }
    => {:name=>"Paul", :age=>35}
    
More concise Syntax new in Ruby 1.9    
    
    .terminal
    >> { name: "Paul", age: 35 }
    => {:name=>"Paul", :age=>35}
    
You can use Strings or any other object for the keys, but Symbols are most common    
    
    .terminal
    >> { "name" => "Paul", "age" => 35 }
    => {"name"=>"Paul", "age"=>35}      

---

# Hash Operators

    >> person = { name: "Paul", age: 35 }
    => {:name=>"Paul", :age=>35}
    
Get the value for a key    
    
    >> person[:name]
    => "Paul"
    
Assign a value to a key
    
    >> person[:city] = "Baltimore"
    => "Baltimore"
    >> person
    => {:name=>"Paul", :age=>35, :city=>"Baltimore"}

If there is no key, you get nil

    .terminal
    >> person[:email]
    => nil
    >> x = nil
    => nil
    >> x.class
    => NilClass

---

# Regular Expressions

Used to see if a String matches a pattern

    .terminal
    >> /oo/.class
    => Regexp    
    >> "food" =~ /oo/
    => 1
    >> "food" =~ /^foo/
    => 0
    >> "food" =~ /d$/
    => 3
    >> "food" =~ /foo$/
    => nil
    >> "food" !~ /foo$/
    => true

---

# Basic Ruby Types

```ruby
# String
"Hello, World!"

# Integer
42

# Float
3.14159

# Boolean
true

# Symbol
:name

# Regexp
/\d/

# Array
[42,99,100]

# Hash
{ :name => "Paul", :age => 35 }

# nil
nil
```

---

# Conditional Statements

`if [condition] then [then expression] else [else expression] end`

    .terminal
    >> x = 42
    => 42
    >> if x > 40 then 1 else 0 end
    => 1

The `else` is optional

    .terminal
    >> if x > 40 then 1 end
    => 1

`unless` is the opposite of `if`

    .terminal
    >> unless x > 40 then 1 end
    => nil

The conditional can be at the end of the line

    .terminal
    >> 1 unless x > 40
    => nil

---

# Truthiness

`nil` and `false` are considered to be "falsy", everything else is "truthy"

    .terminal
    >> x = 42
    => 42
    >> if x then "yes" else "no" end
    => "yes"
    >> x = 0
    => 0
    >> if x then "yes" else "no" end
    => "yes"
    >> x = "false"
    => "false"
    >> if x then "yes" else "no" end
    => "yes"
    >> x = false
    => false
    >> if x then "yes" else "no" end
    => "no"
    >> x = nil
    => nil
    >> if x then "yes" else "no" end
    => "no"

---

# Methods
  
All Objects have methods. You can call a method with `object.method`  

    .terminal
    >> "hello".upcase
    => "HELLO"

Methods can have arguments

    .terminal
    >> "hello,goodbye".split(',')
    => ["hello", "goodbye"]

The parenthesis are optional

    .terminal
    >> "Hello,goodbye".split ','
    => ["Hello", "goodbye"]

The Object's Class dictates what methods an Object has

---

# Object Methods

Determine what type of Object it is

    .terminal
    >> :hello.class
    => Symbol
    >> nil.class
    => NilClass

Ask an object if it is a a certain type

    .terminal
    >> :hello.is_a?(Symbol)
    => true
    >> :hello.is_a?(Object)
    => true
    >> :hello.is_a?(String)
    => false

Methods that end in a question mark are usually methods that return `true` or `false` as the answer to a "question"

---

# Object Methods

Get the string representation of an Object

    .terminal
    >> :hello.to_s
    => "hello"
    >> nil.to_s
    => ""

Get a more detailed representation of an Object for debugging

    .terminal
    >> :hello.inspect
    => ":hello"
    >> nil.inspect
    => "nil"

---

# Object Methods

Create a copy of the Object

    .terminal
    >> my_name = "John"
    => "John"
    >> name = my_name.dup
    => "John"
    >> my_name << " Doe"
    => "John Doe"
    
The original Object has been modified
    
    .terminal
    >> my_name
    => "John Doe"
    
The copy has not
    
    .terminal
    >> name
    => "John"

---

# Object Methods

Freeze an object so it cannot be changed

    .terminal
    >> name.freeze
    => "John"
    >> name << " Doe"
    RuntimeError: can't modify frozen String
    	from (irb):38
    	from /Users/pbarry/.rbenv/versions/2.0.0-p0/bin/irb:12:in `<main>'

---

# String Methods

Change the case of characters in a String

    .terminal
    >> "hello".capitalize
    >> "Hello"
    >> "hello".upcase
    => "HELLO"
    >> "hello".upcase.downcase
    => "hello"

Split a String into an Array

    .terminal
    >> "hello word".split
    => ["hello", "world"]
    >> "hello, world!".split(',')
    => ["hello", " world!"]

Remove whitespace from the beginning and the end

    .terminal
    >> "  hello  ".strip
    => "hello"


---

# String Methods

Replace parts of a String

    .terminal
    >> "hello world".sub('hello','goodbye')
    => "goodbye world"

Replace all occurrences of a String

    .terminal
    >> "one two one".sub('one','three')
    => "three two one"
    >> "one two one".gsub('one','three')
    => "three two three"

Get a "slice" of a String

    .terminal
    >> "hello world".slice(0)
    => "h"
    >> "hello world".slice(-1)
    => "d"
    >> "hello world".slice(4,4)
    => "o wo"    

---

# Array Methods

    .terminal
    >> a = [42,99,100]
    => [42, 99, 100]

Determine how many elements are in the Array

    .terminal
    >> a.size
    => 3
    >> a.length
    => 3

Join an Array into a String separated by a character

    .terminal
    >> a.join(',')
    => "42,99,100"

Get the first/last elements of an array

    .terminal
    >> a.first
    => 42
    >> a.last
    => 100

---

# Array Methods

Add/remove an element from the end of the Array

    .terminal
    >> a.push 120
    => [42, 99, 100, 120]
    >> a.pop
    => 120
    >> a
    => [42, 99, 100]

Add/remove an element from the front of the Array

    .terminal
    >> a.unshift 1
    => [1, 42, 99, 100]
    >> a.shift
    => 1
    >> a

---

# Array Methods

Remove an element from the Array

    .terminal
    => [42, 99, 100]
    >> a.delete 100
    => 100
    >> a
    => [42, 99]

Find the index of an element in the Array

    .terminal
    >> a.index(99)
    => 1

Remove an element from the Array by index

    .terminal
    >> a.delete_at(1)
    => 99
    >> a
    => [42]

---

# Hash Methods

    .terminal
    >> person = { name: "Paul", age: 35 }
    => {:name=>"Paul", :age=>35}

Get the keys of the Hash

    .terminal
    >> person.keys
    => [:name, :age]
    
Get the values of the Hash

    .terminal
    >> person.values
    => ["Paul", 35]

---

# Hash Methods

Merge hashes

    .terminal
    >> person.merge(name: "Paul Barry", city: "Baltimore")
    => {:name=>"Paul Barry", :age=>35, :city=>"Baltimore"}
    
`merge` returns a new Hash, does not modify the Hash
    
    >> person
    => {:name=>"Paul", :age=>35}
    
`merge!` modifies the Hash
    
    >> person.merge!(name: "Paul Barry", city: "Baltimore")
    => {:name=>"Paul Barry", :age=>35, :city=>"Baltimore"}
    >> person
    => {:name=>"Paul Barry", :age=>35, :city=>"Baltimore"}

Having two versions of a method, one that ends without an exclamation mark and does not modify the Object and another that ends with an exclamation mark that does modify the Object, is a common idiom

  </textarea><div id="slideshow"></div>
  </body>
</html>
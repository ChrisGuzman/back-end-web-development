<!DOCTYPE html>
<html>
  <head>
    <title>Security</title>
    <meta charset="utf-8" />

    <script src="js/remark-0.4.4.min.js"></script>
    <script src="js/jquery.min.js"></script>

    <script>
      remark.config({
        highlightStyle: "solarized_dark"
      });

      var hljs = remark.highlighter.engine();

      // extract the embedded styling from ansi spans
      remark.on('ready', function() {
        $('code.terminal > span.ansi').replaceWith(function(i, x) {
          return(x.replace(/&lt;(\/?(\w+).*?)&gt;/g, '<$1>'))
        });
      });
    </script>
    <script src="js/terminal.language.js"></script>
    <link rel="stylesheet" type="text/css" href="css/droid_serif.css" />
    <link rel="stylesheet" type="text/css" href="css/yanone_kaffeesatz.css" />
    <style type="text/css">
      body {
        font-family: 'Droid Serif';
        font-size: medium;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .small * {
        font-size: small !important;
      }
      code {
        border-radius: 5px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .footnote {
        position: absolute;
        font-size: small;
        bottom: 3em;
        right: 3em;
      }
    </style>
  </head>
  <body><textarea id="source" readonly>

class: middle, center

# Security

[http://pjb3.me/bewd-security](http://pjb3.me/bewd-security)

.footnote[
  created with [remark](http://github.com/gnab/remark)
]

---

# Plain Text Password

In our first implementation of sign up, where we collected a password from the user upon sign up and then store that password in the database in plain text:

    .terminal
    $ rails dbconsole
    psql (9.2.1)
    Type "help" for help.

    betastore_development=# select email, password from customers;
          email       | password
    ------------------+----------
     test@example.com | secret

## Why is this bad?

The most simple reason is that people frequently use the same email/password combination on multiple web sites. If someone ever gains access to your database, they could then use those email/password combinations at gmail.com, apple.com, amazon.com, etc. and some of them will work.

---

# Hashing Passwords

To solve this problem, we hash the password when we store it. A hashing function is one where if we hash the same value, we get the same result, but given the result, we can't tell what value was used to create it.

A common hashing function is MD5. Here's how you could use it:

    .terminal
    $ rails c
    >> password_digest = Digest::MD5.hexdigest('secret')
    => "5ebe2294ecd0e0f08eab7690d2a6ee69"
    >> password_digest == Digest::MD5.hexdigest('fail')
    => false
    >> password_digest == Digest::MD5.hexdigest('secret')
    => true

First we hash the user's actual password, which is `"secret"` and we store that in a variable. Then we show how you would check when someone is logging in if the password is correct. You hash what they enter and then compare that to the original digest.

Although MD5 would be better than nothing, there are still ways to "guess" the original password if you have the MD5 digest of the password. A more secure algorithm that is much harder to guess the original password is Bcrypt.

More Info: [http://codahale.com/how-to-safely-store-a-password](http://codahale.com/how-to-safely-store-a-password)

---

# Bcrypt

Because Bcrypt is a good choice for storing passwords, Rails has built-in support for it. To use it, first add the bcrypt gem to the `Gemfile`:

```ruby
gem 'bcrypt-ruby', '~> 3.0.0'
```

Then run `bundle` to install it:

    .terminal
    $ bundle

---

# Password Digest Column

To use the built-in Bcrypt password functionality for our customer passwords, we need to drop the plain text password column from the database and add a password_digest column:

    .terminal
    $ rails g migration remove_password_from_customers password
          invoke  active_record
          create    db/migrate/20131010013848_remove_password_from_customers.rb
    $ rails g migration add_password_digest_to_customers password_digest
          invoke  active_record
          create    db/migrate/20131010013921_add_password_digest_to_customers.rb
    $ rake db:migrate
    ==  RemovePasswordFromCustomers: migrating ====================================
    -- remove_column(:customers, :password, :string)
       -> 0.0120s
    ==  RemovePasswordFromCustomers: migrated (0.0121s) ===========================

    ==  AddPasswordDigestToCustomers: migrating ===================================
    -- add_column(:customers, :password_digest, :string)
       -> 0.0031s
    ==  AddPasswordDigestToCustomers: migrated (0.0032s) ==========================

---

# Has Secure Password

Next we have to do is add `has_secure_password` to the `Customer` model in `app/models/customer.rb`:

```ruby
class Customer < ActiveRecord::Base
  has_many :orders
  has_many :line_items, :through => :orders
  has_many :products, :through => :line_items

  validates_presence_of :name, :email

  has_secure_password
end
```

---

# Setting Passwords

If you have any existing customers, they won't have a password now:

    .terminal
    $ rails dbconsole
    psql (9.2.1)
    Type "help" for help.

    betastore_development=# select email, password from customers;
          email       | password
    ------------------+----------
     test@example.com |

You can assign each customer a password in the `rails console` like this:

    .terminal
    $ rails console
    >> Customer.where(password_digest: nil).each{|c| 
      c.password = c.password_confirmation = 'secret'; c.save! }

---

# Dummy Authentication

If you remember back to when we originally created `log_ins#create`, it looks like this:

```ruby
class LogInsController < ApplicationController
  def create
    if params[:password].present?
      cookies[:email] = params[:email]
      redirect_to products_path
    else
      redirect_to log_in_path, alert: 'Log In Failed'
    end
  end
end
```

Because we are just checking if the password is present, this isn't a real log in, it will accept any email/password combination. Now we can update it to a real implementation

---

# Real Authentication

```ruby
class LogInsController < ApplicationController
  def create
    customer = Customer.find_by(email: params[:email])
    if customer && customer.authenticate(params[:password])
      cookies[:customer_id] = customer.id
      redirect_to products_path
    else
      redirect_to log_in_path, alert: 'Log In Failed'
    end
  end
end
```

In this version, we look up the `Customer` using the email and then if we find one and if successfully authenticates using the password that was supplied, then we set the ID of the `Customer` in a cookie.

We were previous using email as the cookie, but we're switching it to `customer_id` now that we have a database record for the customer. This is a better choice in case our customer changes their email address, they won't have to log out and log back in.

Search for `cookies` in the project make sure it is using `customer_id` instead of `email`

---

# Don't Trust Cookies

The next security problem that we have in our application is that to be logged in as a `Customer`, all you have to do is set a cookie called `customer_id` with the value of the Customer ID that you want to be logged in as. One of the key things about security of web applications to keep is mind is...

# Never Trust User Input

Any user who knows a little bit about how web applications work can set cookies or other parameters to any value they want. For example, if we get the home page without the email cookie:

    .terminal
    $ curl -I http://localhost:3000
    HTTP/1.1 302 Found
    Location: http://localhost:3000/log_in

We are redirected to the log in page. But if we supply an email for the cookie:

    .terminal
    $ curl -I -H 'Cookie: customer_id=1' http://localhost:3000
    HTTP/1.1 200 OK

Then the application thinks we are logged in and we are not sent to the log in page. If our application allows users to view/modify customer information, this could be a serious problem

---

# Signing Cookies

One way to protect against this type of vulnerability is to sign the cookie. This means that instead of just the raw value, you add on a digest based on a key only you know and the value.

A simple way to sign a value is to pick a key somehow that you keep a secret:

    .terminal
    >> key = "It's a Secret To Everybody"
    => "It's a Secret To Everybody"

Then, to set the value of the cookie, you combine the value (in this case the email) with the key and get the MD5 digest of that:

    .terminal
    >> customer_id = 1
    => 1
    >> digest = Digest::MD5.hexdigest("#{customer_id}-#{key}")
    => "3297cc25fe3c7f13d2e0e40d9d886cab"

Then, you combine the value with the digest and set that as a cookie with some known delimiter, like this:

    .terminal
    >> cookie = "#{customer_id}-#{digest}"
    => "1-3297cc25fe3c7f13d2e0e40d9d886cab"

---

# Verifying a Signed Cookie

Now to verify a signed cookie, you do the process in reverse. First, you split the value in the cookie based on the delimiter:

    .terminal
    >> customer_id, digest = cookie.split('-')
    => ["1", "3297cc25fe3c7f13d2e0e40d9d886cab"]

Then, you generate the digest for the customer_id and check that it matches the digest that was in the cookie:

    .terminal
    >> Digest::MD5.hexdigest("#{customer_id}-#{key}") == digest
    => true

If the values do not match, it means that the user modified or forged the cookie, therefore you would ignore the value and not log them in. If the values do match, then you can trust the cookie.

---

# Rails Signed Cookies

Because signing cookies is a good security practice, Rails has support for them built in. All we have to do is change how we set the cookie in the `create` action in `LogInsController` to be like this:


```ruby
cookies\.signed[:customer_id] = customer.id
```

And change how we check it in the `logged_in?` method in `app/controllers/application_controller.rb` to be like this:

```ruby
cookies\.signed[:customer_id].present?
```

And that's it! If you are wondering where the key that the cookies are being signed with is, take a look at `config/initializers/secret_token.rb`

---

# Mass-Assignment

---

# Cross-Site Scripting

---

# SQL Injection

---

# Cross-Site Request Forgery

  </textarea><div id="slideshow"></div>
  </body>
</html>
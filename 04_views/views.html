<!DOCTYPE html>
<html>
  <head>
    <title>Views</title>
    <meta charset="utf-8" />

    <script src="js/remark-0.4.4.min.js"></script>
    <script src="js/jquery.min.js"></script>

    <script>
      remark.config({
        highlightStyle: "solarized_dark"
      });

      var hljs = remark.highlighter.engine();

      // extract the embedded styling from ansi spans
      remark.on('ready', function() {
        $('code.terminal > span.ansi').replaceWith(function(i, x) {
          return(x.replace(/&lt;(\/?(\w+).*?)&gt;/g, '<$1>'))
        });
      });
    </script>
    <script src="js/terminal.language.js"></script>
    <link rel="stylesheet" type="text/css" href="css/droid_serif.css" />
    <link rel="stylesheet" type="text/css" href="css/yanone_kaffeesatz.css" />
    <style type="text/css">
      body {
        font-family: 'Droid Serif';
        font-size: medium;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .small * {
        font-size: small !important;
      }
      code {
        border-radius: 5px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .footnote {
        position: absolute;
        font-size: small;
        bottom: 3em;
        right: 3em;
      }
    </style>
  </head>
  <body><textarea id="source" readonly>

class: middle, center

# Views

[http://pjb3.me/bewd-views](http://pjb3.me/bewd-views)

.footnote[
  created with [remark](http://github.com/gnab/remark)
]

---

# Views

Views, the V in MVC, are responsible for generating the visual elements of an application, which is typically HTML

---

# ERB

Embedded Ruby (ERB) is the default templating language in Rails. It looks like this

    .terminal
    Hello, <%= @name %>

if name is set to `"Paul"`, that becomes

    .terminal
    Hello, Paul

`<% %>` are used for expressions that don't return a value

    .terminal
    <% if @name %>
      Hello, <%= @name %>
    <% else %>
      Welcome, Guest
    <% end %>

The code between the `<% %>` and `<%= %>` is Ruby

---

# View Location

Views are located in the `app/views` directory of a Rails application. For each controller, there is a corresponding directory in `app/views`. For example, the views for the `OrdersController` are located in `app/views/orders`.

The name of a view matches the name of the action. So for the `new` action of the `OrdersController`, will be in the `app/views/orders` directory in a file that starts with `new`.

The full name will typically have 2 file extensions, separated by periods. The first extension specifies which format the template is for and the second extension specifies what kind of template it is. The most common format is `html`, we will talk about alternate formats later. Also, ERB is the most common type of template, we will cover other types later.

Putting all of this together, the view for `orders#new` (the new action of the orders controller) will most likely be:

    .terminal
    app/views/orders/new.html.erb

* All views go in `app/views`, so that is beginning of the path

* Since it is for the orders controller, the next directory in the path is `orders`

* Since it is for the `new` action, the file name starts with `new`

* The format is `html`, so the first extension is .`html`

* The template type is `ERB`, so the second extension is `.erb`.

---

# Instance Variables

We have already seen this, but all instance variables that are set when the action is execute are available to the view. For example, when set the instance variable `@message` in `orders#new`:

```ruby
class OrdersController < ApplicationController
  def new
    @title = "Checkout"
  end
end
```

We can access it from the `app/views/orders/new.html.erb`:

```html
<h1><%= @title %></h1>
```

This will print `Checkout` in a heading

---

# Layouts

The HTML generated by the view is just for the main part of the page. Once the main views has been rendered, the result is stored in a temporary variable and then passed into the layout. The `yield` statement retrieves that temporary variable:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Betastore</title>
  </head>
  <body>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>
```

In this example, the rendered output of the view will be inserted into `div`

---

# Using Instance Variables In the Layout

The layout has access to the same instance variables the view does:

```ruby
class OrdersController < ApplicationController
  def new
    @title = "Checkout"
  end
end
```

```html
<!DOCTYPE html>
<html>
  <head>
    <title><%= @title %></title>
  </head>
  <body>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>
```

In this example, the title of the HTML document will be set to `Checkout`

---

# Setting Instance Variables In the View

You can set/modify instance variables in the view

```ruby
class OrdersController < ApplicationController
end
```

```html
<% @page_title = "Checkout" %>

<h1><%= @page_title %></h1>
```

Since the view is rendered before the layout, we can then access that instance variable from the layout

```html
<!DOCTYPE html>
<html>
  <head>
    <title><%= @page_title %></title>
  </head>
  <body>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>
```

Now we will have an HTML document with a title of `Checkout` and a heading in the body of `Checkout`

---

# Partials

You might find that you have some bits of view code that you would like to share between different views. You can do this with partials. Partials differ from normal views in that their name starts with an `_`. For example, say we have an order summary that we want to show when someone is checking out, but then we want to display the same information on the confirmation page once the customer's order been placed. To do that, first we would put this in the view:

```html
<%= render 'order' %>
```

Since we are using `render` from within a view, this means to render a partial in the same directory as the view that is named `order`. Then we can put something into `app/views/orders/_order.html.erb`:

```html
<h2>Order Details</h2>
```

We can fill that out with more content later, but for now, when you go to http://localhost:3000/orders/new you will see the main heading for the page title and then the secondary heading that says `Order Details` from the partial.

If you need to use a partial from a directory other than the one the current view is in, just use the path to the partial relative to `app/views`. For example, if you had a partial in `app/views/shared/_sidebar.html.erb`, you could render that from the orders new view in `app/views/orders/new.html.erb` like this:

```html
<%= render 'shared/sidebar' %>
```

Partials will always use the same format as the main view. In theory, the template type for a partial could be different than the one used in the main view, although that is very rare.

---

# Partials In Layouts

Partials can be used in layouts, which is a fairly common technique. For example, we might want to include a footer on every page, which we could do like this

```ruby
<!DOCTYPE html>
<html>
  <head>
    <title>Betastore</title>
  </head>
  <body>
    <div class="container">
      <%= yield %>
      <%= render 'layouts/footer' %>
    </div>
  </body>
</html>
```

Notice that you so have to use `layouts/footer` instead of just `footer` because the default directory is based on the directory the main view is in, not the directory the layout is in.

In `app/views/layouts/_footer.html.erb` you would put something like:

```html
<hr />
&copy; Betamore <%= Time.current.year %>
```

Now if you create other layouts, they could all render this partial and share the same footer.

---

# Helpers

Helpers are Ruby methods that you can call in views, layout and partials. There are many helpers that are built into Rails and you can define your own custom helpers.

Helpers are typically used for formatting or generating HTML tags.

---

# Generating URLs

The helper `url_for` is used to generate urls based on the controller and action. You can pass just an action and the current controller will be used. For example, if you are rendering the view for the new action of the orders controller and you called `url_for` like this:

    .terminal
    <%= url_for action: 'index' %>

The output would be `/orders`, because that is the path for the orders controller's index action. You can refer to the action of another controller by using the controller option:

    .terminal
    <%= url_for controller: 'log_ins', action: 'new' %>

This will generate a path of `/log_in`, not `/log_ins/new`, as you might expect. That is because `url_for` does the reverse process of routing, by finding the route that matches the controller and action and then returns the path for that route.

---

# Named Routes

Most of the time you will not use `url_for` directly, you instead use the named routes. When you have routes defined like this:

```ruby
resources :products, only: [:index, :show]
```

You will see this when you run `rake routes`:

    .terminal
    $ rake routes
      Prefix Verb   URI Pattern                             Controller#Action
    products GET    /products(.:format)                     products#index
     product GET    /products/:id(.:format)                 products#show

The 'Prefix` is the name for that route. There is a helper generated for each named route that you can call by appending `_path` to the route prefix, like this:

    .terminal
    <%= products_path %>
    
That will output `/products`

---

# Named Routes With Parameters

For routes like the `product` route for `products#show`, you pass in an argument for the id of the product, which you can do like this:

    .terminal
    <%= product_path(1) %>

Which will output `/products/1`. You can also pass an instance of a model to a named route method and it will get the value from the id of the model:

    .terminal
    <%= product_path(@product) %>

Assuming `@product` is a reference to the `Product` with an `id` = `1`, this will also output `/products/1`.

---

# Generating Links

For generating links, you can use the `link_to` helper. The first argument is the text that you want to displayed for the link. The second argument is the URL you want the link to go to. So if `product` is a variable that is a reference to a Product with id = 1 and name = Hat, then this:

    .terminal
    <%= link_to product.name, product_path(product) %>

Will generate:

```html
<a href="/products/1">Hat</a>
```

There is an optional third argument to `link_to` which is a Hash that you can use to set attributes on the `a` tag, like this:

    .terminal
    <%= link_to product.name, product_path(product), class: 'product' %>

Will generate:

```html
<a href="/products/1" class="product">Hat</a>
```

---

# Formatting Text

There are some helpers related to formatting of text. You can truncate a string like this:

    .terminal
    <%= truncate "This is a string that is more than 30 characters" %>

Will output `This is a string that is mo...`

`simple_format` replaces line breaks in a string with HTML paragraph tags.

    .terminal
    <%= simple_format "first paragraph\n\nsecond paragraph" %>

```html
<p>first paragraph</p>
<p>second paragraph</p>
```

---

# Formatting Text

Sometimes you might want to display a word in singular if there is just 1 and pluralize it otherwise. The `pluralize` method does that for you if `@products.size` is 1, then:

    .terminal
    <%= pluralize @products.size, 'product' %>

Would print:

    .terminal
    1 product

But if `@products.size` is more than 1, it would print:

    .terminal
    2 products

---

# Formatting Text

Although not technically a helper, a good method to know about is `titleize`. Sometimes you might have the name of a class or an attribute in a variable and you might want to print it out in a human readable way.

    .terminal
    <%= 'LineItem'.titleize %>

Will output:

    .terminal
    Line Item
    
This will output the same thing:

    .terminal
    <%= 'line_item'.titleize %>

---

# Formatting Dates

There is a helper that you can use to translate a time to a distance of time. For example, if you have a product that was created 5 days ago, this:

    .terminal
    <%= time_ago_in_words product.created_at %>

Will output `5 days`. It will work for a variety of time ranges, like "less than a minute", "about an hour", etc.

You can use `strftime` to format a date or a time into a string:

    .terminal
    <%= Time.current.strftime('%a, %b %e') %>

That will output:

    Tue, Oct  8

`strftime` uses a little language which you can find more about at [http://www.foragoodstrftime.com](http://www.foragoodstrftime.com)

---

# Formatting Numbers

Print a number as a dollar amount

```ruby
number_to_currency(2.99) # => $2.99
```

Print a number in words

```ruby
number_to_human(1000000) # => 1 Million
```

Print a number of bytes

```ruby
number_to_human_size(1234567) # => 1.18 MB
```

Add commas to a large number

```ruby
number_with_delimiter(1000000) # => 1,000,000
```

Round a number, defaults to 3 decimal places, you can control it with precision:

```ruby
number_with_precision(1.2345) # => 1.235
number_with_precision(1.2345, precision: 2) # => 1.23
```

---

# Form Tags

Our log in form contains just HTML:

```html
<form method="POST" action="/log_in">
  <label for="email">Email</label>
  <input type="email" name="email" id="email" />
  
  <label for="password">Password</label>
  <input type="password" name="password" id="password" />
  
  <button type="submit">Log In</button>
</form>
```

Rails provides several form helpers that you can use to build the same form.

---

# Form Tags

This will generate equivalent HTML:

```html
<%= form_tag do %>
  <%= label_tag :email %>
  <%= email_field_tag :email %>
  
  <%= label_tag :password %>
  <%= password_field_tag :password %>

  <%= button_tag "Log In" %>
<% end %>
```

`form_tag` takes a Hash with the same arguments as `url_for`. The form defaults to a `POST`, so in this case, we don't have to pass any arguments.

---

# Pre-filling Values

If you want a field to have a value already entered when you show the form, you make that the second argument to the tag helper:

```html
<%= email_field_tag :email, params[:email] %>
```

In this case we are using the value of the param named email. If there is one, the value will appear there, if not, the form field will be blank

---

# Add a Password

In many cases, you will have a form that maps directly to the attributes of a model. For example, let's say we want to create a form to allow customers to sign up. There a few things we need to have in place so we can do that. First, we want users to be able to specify a password when they create their account, but we don't have a field for that yet, so let's add that using a migration:

    .terminal
    $ rails g migration add_password_to_customers password:string
      invoke  active_record
      create    db/migrate/20131008134833_add_password_to_customers.rb

This will create a migration that looks like this:

```ruby    
class AddPasswordToCustomers < ActiveRecord::Migration
  def change
    add_column :customers, :password, :string
  end
end
```

We can run `rake db:migrate` to make the column actually be added to the database:

    .terminal
    $ rake db:migrate
    ==  AddPasswordToCustomers: migrating =========================================
    -- add_column(:customers, :password, :string)
       -> 0.0094s
    ==  AddPasswordToCustomers: migrated (0.0095s) ================================

---

# Customers Table

Our `customers` table should now look like this:

    .terminal
    $ rails dbconsole
    psql (9.2.1)
    Type "help" for help.

    betastore_development=# \d customers
                                         Table "public.customers"
       Column   |            Type             |                       Modifiers
    ------------+-----------------------------+--------------------------------------------------------
     id         | integer                     | not null default nextval('customers_id_seq'::regclass)
     name       | character varying(255)      |
     email      | character varying(255)      |
     created_at | timestamp without time zone |
     updated_at | timestamp without time zone |
     password   | character varying(255)      |
    Indexes:
        "customers_pkey" PRIMARY KEY, btree (id)

---

# Adding Routes

Since we are making a form to create a `Customer`, we know we are going to need a `CustomersController` with a `new` action to display the form and a `create` action to actually create the customer. Following the REST convention, our routes would look like this:

```ruby
resources :customers, only: [:new, :create]
```

And although this would work, the routes would be a bit odd, because customers don't think of this as creating a customer record, they think of it as signing up, so let's use some custom routes instead:

```ruby
 get '/sign_up' => 'customers#new', as: 'sign_up'
post '/sign_up' => 'customers#create'
```

Now we have our routes but we need a controller

---

# Controller

Here what the `new` and `create` actions are going to look like for customers controller:

```ruby
class CustomersController < ApplicationController
  skip_before_filter :require_log_in, only: [:new, :create]
  
  def new
    @customer = Customer.new
  end
  
  def create
    @customer = Customer.new(customer_params)
    if @customer.save
      redirect_to log_in_path
    else
      render 'new'
    end
  end

  private
  def customer_params
    params.require(:customer).permit(:name, :email)
  end
end
```

Let's go through each part step by step

---

# New Action

First, we see we are skipping the `require_log_in` before filter:

```ruby
skip_before_filter :require_log_in, only: [:new, :create]
```

It doesn't make sense to require the customer to be logged in to sign up, so we'll just skip that on our `new` and `create` actions. We could have left the `only` off, because currently `new` and `create` are the only actions the controller has, but it's a better practice to list the actions individually, because if we add another action, we don't want to accidentally allow non-logged in users to access it.

The `new` action looks like this:

```ruby
def new
  @customer = Customer.new
end
```

Here we set up an empty `Customer` instance to work with in the view. As you will see shortly, it is going to be easy to create our form in the view if we always have a `@customer` to use.

---

# Create Action

The create action looks like this:

```ruby
def create
  @customer = Customer.new(customer_params)
  if @customer.save
    redirect_to log_in_path, notice: 'Your account was created, please log in'
  else
    render 'new'
  end
end
```

First we create a `@customer` instance that is initialized using the customer params, we'll look at `customer_params` in a minute, but know it's import to know that it will return a Hash that will look something like:

```ruby
{ :name => 'Paul Barry', :email => 'mail@paulbarry.com', :password => 'secret' }
```

Assuming that `customer_params` does return that, or something similar based on whatever is actually entered into the form, that will populate the attributes of the `@customer` object, so the next thing we will do is save it.

If the object is saved, `@customer.save` will return true, at which point we will redirect the log in form. If the object is not saved, presumably there is some kind of validation error, we we will show the user the form again, but with the form fields filled in to whatever they entered.

It's an important to know that calling `render 'new'` means render the `new` template, it does not mean call the `new` action.

---

# Customer Params

In our create action, we call the `customer_params` method, which looks like this:

```ruby
private
def customer_params
  params.require(:customer).permit(:name, :email, :password)
end
```

First, we make this method private just to indicate that this method is not an action that should be called directly, it is a method used by other actions.

Next, we call `params.require(:customer)`, which means that there needs to be a `:customer` key in the params, which there will be based on the way we set up our form shortly.

Then we call `permit` on the result of that `require` call. The arguments to `permit` are attributes that we will allow to be set via the form post. This is a security measure to prevent someone from submitting a value for an attribute other than the ones that we specify here.

We will cover this in more detail when we go over security, but for know we need to know that this means we expect the form to submit parameters that look like this:

```ruby
:customer => { 
  :name => 'Paul Barry', 
  :email => 'mail@paulbarry.com', 
  :password => 'secret' 
}
```

There is a `customer` key in params that has a Hash as it's value

---

# Validations

One last thing we need to do before moving on to the form is make sure the `Customer` model has validations that make each attribute a required value. We've seen how to do that already, so we know that we can add this to the model in `app/models/customer.rb`, so the whole model should look like this:

```ruby
class Customer < ActiveRecord::Base
  has_many :orders
  has_many :line_items, :through => :orders
  has_many :products, :through => :line_items

  validates_presence_of :name, :email, :password
end
```

---

# Form

First we are going to do a version of our form that uses the `form_tag` and other tag helpers that we've already looked at. Our form will look like this:

```html
<%= form_tag do %>
  <div>
    <%= label_tag 'customer_name', 'Name' %>
    <%= text_field_tag 'customer[name]', @customer.name %>
  </div>
  
  <div>
    <%= label_tag 'customer_email', 'Email'  %>
    <%= email_field_tag 'customer[email]', @customer.email %>
  </div>
  
  <div>
    <%= label_tag 'customer_password', 'Password'  %>
    <%= password_field_tag 'customer[password]', @customer.password %> 
  </div>

  <%= button_tag 'Sign Up' %>
<% end %>
```

The thing that looks different here is the name of our tags start with `customer` and have the name of the attribute in square brackets. Submit the form with no values and you should be taken right back to the form.

---

# Parameters

If you look at the output from `rails server`, should should see something like this:

    .terminal
    Started POST "/sign_up" for 127.0.0.1 at 2013-10-08 09:37:55 -0500
    Processing by CustomersController#create as HTML
    Parameters: {"customer"=>{"name"=>"", "email"=>"", "password"=>"[FILTERED]"}}
    Rendered customers/new.html.erb within layouts/application (1.1ms)
    Completed 200 OK in 19ms (Views: 8.9ms | ActiveRecord: 0.5ms)

I've cut out some of the non-essential parts to make it easier to read. The key thing to note is that the parameters does have a key of `customer` with a value of a Hash with keys for `name`, `email` and `password`. This happened because of how we used square brackets in the names of our fields. When Rails sees parameters named like this:

    .terminal
    customer[name]
    customer[email]
    customer[password]

Because the first part of all those names before the square brackets match up, Rails knows to combined them into one Hash.

This makes it easy to group parameters together. In this case, we know all parameters related to the customer will be in that Hash.

---

# Displaying Errors

When we submitted the form, it immediately displayed the form again. This was because `@customer` did not save due to validation errors, but we did not display our validation errors anywhere in the view, so it's hard to understand what happened. Add this in the template just above the `form_tag`:

```html
<% if @customer.errors.present? %>
  <ul>
    <% @customer.errors.full_messages.each do |error| %>
      <li><%= error %></li>
    <% end %>
  </ul>
<% end %>
```

Now in the form, fill in a value for name and email, but leave password blank, and then submit the form again. You will see the error for the missing password displayed and the name and the email form fields will be populated with the values that you originally entered.

---

# Form For

Our form works, but this pattern of creating a form to create a model is common enough that Rails has a helper specifically for this. There is a helper called `form_for` and here's what our form looks like when we convert it to use that:

```html
<%= form_for @customer, url: sign_up_path do |f| %>
  <div>
    <%= f.label :name %>
    <%= f.text_field :name %>
  </div>
  
  <div>
    <%= f.label :email %>
    <%= f.email_field :email %>
  </div>
  
  <div>
    <%= f.label :password %>
    <%= f.password_field :password %> 
  </div>

  <%= f.submit 'Sign Up' %>
<% end %>
```

---

# Form For

First is the `form_for` helper, which we are using in place of `form_tag`. If we try to use `form_for` in the same way as we did with `form_tag`, like this:

```html
<%= form_for @customer do |f| %>
```

We would get an error about `customers_path` not being defined. This is because `form_for` assumes you are using the RESTful convention by default, but in our case we are not, so that is why we specify the url via an option:

```html
<%= form_for @customer, url: sign_up_path do |f| %>
```

Also notice that compared to `form_tag`, which uses a block with no argument, `form_for` has a block argument, which is commonly named `f`, short for "form'. This argument to the block is then used in the form, where we call a method on that object that matches up to the other helpers, except it doesn't have `_tag` on the end.

The benefit of these helpers is that the value of the field is set based on the object the form is bound to, so instead of this:

```html
<%= text_field_tag 'customer[name]', @customer.name %>
```

We do this:

```html
<%= f.text_field :name %>
```

---

# Custom Helpers

We have been using a variety of helpers built in to Rails throughout this lesson, but you can also create your own helper methods. This is what the `app/helpers` directory is for. It contains modules that have methods that you can use as helpers in the views. There can be many files/modules in this directory and all methods defined in there will be accessible via the views. Separate files are just used for organization purposes.

For example, in our footer, we currently have the copyright year displayed using:

```html
<%= Time.current.year %>
```

But imagine we anticipate having a more complex method of determining what year should be used and possibly we needed to refer to it from multiple places throughout the application. We can create a helper in `app/helpers/application_helper.rb` like this:

```ruby
module ApplicationHelper
  def copyright_year
    Time.current.year
  end
end
```

We can now call this form the view simply by calling the method:

```html
<%= copyright_year %>
```

---

# Homework

Use some helpers to make some enhancements to the page that lists all products:

* Use `number_to_currency` to display the price for each product
* Use `time_ago_in_words` to display how long ago the product was created
* Create a custom helper to display the product name as "product name - #product id"

Let's also improve the log in / sign up flow

* On the log in page, add a link to sign up that says something like "Don't have an account yet? Sign Up"
* Do the reverse on the sign up page, add a link to log in that says something like "Already have an account? Log In"
* Make so that upon completing the sign up, you are automatically logged in and taken to the product listing, instead of having to log in

## Extra Credit

* Storing password as plain text in the database is insecure. Rails has a built in mechanism to solve that problem, called `has_secure_password`. The documentation for it is here:

http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password

Update the application to use `has_secure_password` instead of a plain text password

  </textarea><div id="slideshow"></div>
  </body>
</html>
